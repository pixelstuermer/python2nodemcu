:source-highlighter: rouge
:toc:                macro
:toclevels:          2
:toc-title:

image:https://img.shields.io/github/license/pixelstuermer/python2nodemcu[link=LICENSE]
image:https://img.shields.io/github/v/release/pixelstuermer/python2nodemcu[link=https://github.com/pixelstuermer/python2nodemcu/releases/latest]
image:https://github.com/pixelstuermer/python2nodemcu/workflows/AsciiDoc%20to%20PDF/badge.svg[link=https://github.com/pixelstuermer/python2nodemcu/actions] +
image:https://img.shields.io/badge/python-3.7.4-blue[link=https://www.python.org/downloads/release/python-374]
image:https://img.shields.io/badge/platform-MacOS_(Sierra)-blue[]
image:https://img.shields.io/badge/board-NodeMcu-blue[link=https://www.nodemcu.com/index_en.html]

[discrete]
= python2nodemcu :snake:

The web is full of tutorials and documentation on how to develop Lua or C++ scripts for https://www.espressif.com/en/products/hardware[ESP microcontrollers] (and boards building on it) and flashing them with the https://www.arduino.cc/en/main/software[Arduino IDE].
But when turning away from this out-of-the-box toolset, the support is getting sparse but still available.

So things get a bit trickier when replacing the language with Python and avoiding the Arduino IDE.
IMHO, support and documentation is indeed still available but not as satisfying as expected.
I somehow found it puzzling that developing and uploading Python scripts for those controllers seems not to be that famous or at least not so well documented.

While researching and trying different things I consulted several resources because none of them was, what I would call, an end-to-end documentation.
This document therefore tries to summarize and provide the lessons I've learned from it.
Furthermore, it is an approach to get started with hacking as fast as possible, instead of entering too many technical depths.

Please see the following table of contents to get insights of the structure and subjects.
Please also note that it is based on MacOS (Sierra), https://www.python.org/downloads/release/python-374[Python 3.7.4] and the https://www.nodemcu.com/index_en.html[NodeMcu board].
Moreover, the Python packages are installed using the manual fashion.
Nevertheless, there are other options to install packages, such as https://pypi.org/project/pip/[Pip].

toc::[]

== Basic Understanding

The NodeMcu board is based on the ESP8266 microcontroller and contains required components such as CPU, RAM and the TCP/IP stack (enabling WiFi network connections).
The System-on-a-chip adds several convenient features, such as more GPIO pins or a micro USB interface.
It is therefore a https://github.com/nodemcu/nodemcu-devkit-v1.0[hardware development kit] for the NodeMcu firmware.
But as just mentioned, it is also an https://github.com/nodemcu/nodemcu-firmware[open source firmware] which runs on the board by default, enabling You to program it using Lua or C++.

The commands are sent to the board via a device file, using the serial UART interface.
For an appropriate power supply, please use proper USB cables and avoid USB hubs.

The development kit all in all enables You to, for example, address the GPIO pins and it allows communication with connected components, such as sensors (in) and actuators (out).
Due to the low cost and easy setup it is very well suited for IoT projects.

== Prerequisites

The following sections give an overview of the requirements, before starting with developing and uploading.

=== Python

Please run one of the following commands to find out if Python 3 is already installed on Your machine:

```sh
python --version
python3 --version
```

The output should look somehow like the following:

```sh
Python 3.7.4
```

If not, please install Python 3 as described https://www.python.org/downloads/release/python-374[here].

=== Driver

Next, the appropriate SiLabs driver must be installed to enable serial USB-to-UART communication with the microcontroller.
Depending on Your operating system, Please download one of these https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers[drivers] and install it.
Your machine should now be able to recognize the board after connecting it via USB.

Nevertheless You won't see the device on first sight, which leads us to the next chapter.

=== Finding the Device File

Device files are a concept to separate client programs from specific device drivers (which then interact with the actual devices).
So they provide interfaces to communicate with devices (which they represent), such as the microcontroller.
Hence, they can be seen as portals to the device drivers and therefore to the physical devices themselves.

They also follow the unix principle of everything being a file.
Writing data to the device file means passing data to the device driver which then sends the data to the actual physical device.

The device files are located in the `/dev` directory, but We still need to figure out which device file represents the microcontroller.
This differs according to the installed driver and the operating system.

Executing the following command will only list a subset of device files, of which one should represent the microcontroller in question:

```sh
ls -la /dev/tty.*
```

Plugging and unplugging the physical device via USB while executing the command should therefore result in different outputs.
Like this, the device file of the microcontroller can be easily discovered.

The result will then be similar to this:

```sh
...
...
/dev/tty.wchusbserialfd130
...
...
```

Please note that Your device file might have a different name.
Therefore, please replace `/dev/tty.wchusbserialfd130` in the following code examples with Your own device file name.

=== Firmware

=== Access to the Serial Port

== Start Hacking

=== Flashing the Firmware

=== Connecting to the Board

=== Running Commands on the Board

=== Developing Scripts

=== Uploading Scripts

== Samples

=== Counter

=== LED

== Links and Resources
